
# 五种无信息搜索算法分析
***人工智能第一次作业***

> 胡泽善 S181000884
## 广度优先算法(Breadth-first Search,BFS)
1. BFS算法描述

    > 算法使用一个先入先出 ***(First In First Out,FIFO)*** 的队列储存接下来只花一步就能扩展的结点。在算法的最开始把根结点也就是搜索的初始状态结点放入队列，接着每一次从队列中取出一个结点，搜索这一结点，然后把该结点没有进入过队列的后继结点放入队列。重复上面从队列中取出结点并搜索的策略，直到搜索到目的状态结点为止。

2. 完备性(Completeness)

    > BFS是一个简单的搜索策略，在搜索过程中会对所有状态进行遍历，所以它在分支因子(Branching factor)$b$的大小有限的前提下是完备的。

3. 时间复杂度(Time Complexity)
    > 这里我们假设目标结点所在的深度为$d$,其中根结点的深度设为0。那么从根开始每一层深度中扩展的结点总和是
    $1+b+b^2+b^3+...+b^d+b(b^d-1)=O(b^{d+1})$
    所以总的时间复杂度是$O(b^{d+1})$

4. 空间复杂度(Space Complexity)

    > 因为每一个结点在被搜索时都会进入一次队列，也就储存在内存中，所以总的空间复杂度是$O(b^{d+1})$

5. 最优性(Optimal)

    > 如果我们把每一步扩展的代价视作1，那么这个算法是最优的

## 一致代价搜索(Uniform Cost Search,UCS)
1. UCS算法描述

    > 在广度优先搜索中，每一次都会选择深度最浅的结点扩展搜索。但是在一致代价搜索中采用代价函数$g(n)$来比较待选择结点，使用优先队列每次选择代价最小的搜索。UCS与BFS的另一个区别就是它还会对队列中结点的最小代价进行更新。
2. 完备性

    > UCS除了改变代价评估方式外，搜索策略与BFS类似，所以它能够保证不管每一步的代价是不是设置成1都能找到最优解。所以在$b$有限时是完备的。
3. 时间复杂度
    > + UCS算法的时间复杂度是由最优解的代价而不是最优解深度决定的。我们假定每一步的代 价至少是$\varepsilon$，而最优解的代价是$C^*$，同时分支因子是$b$
    > + 那么每一次我们扩展一个结点都会遇到$b$个新的结点，到达第$k$层时，我们遇到的结点总数是$1+b+b^2+\dots+b^k=(b^{k+1}-1)/(b-1)$
    > + 由于每一步我们都会更加接近最优解的代价$C$，且每一步代价至少增加$\varepsilon$，所以$k=\lfloor C^*/\varepsilon\rfloor+1$
    > + 所以总地时间复杂度是$O(b^{(\lfloor C^*/\varepsilon\rfloor+1)})$
4. 空间复杂度

   > 类似BFS，UCS的空间复杂度也和它的时间复杂度一样，也是$O(b^{(\lfloor C^*/\varepsilon\rfloor+1)})$
5. 最优性

   > 由于扩展的结点严格按代价上升的顺序排列，所以是最优的

## 深度优先算法(Depth first Search,DFS)
1. DFS算法描述

   > 在深度优先算法中维护了一个后进先出 ***(Last In First Out,LIFO)*** 栈，算法开始时搜索初始结点并把结点压入栈。在这之后，每一次都会取栈顶结点没有搜索过的后继结点进行搜索，再把该结点压入栈顶。直到栈顶结点没有符合要求的后继结点时，就弹出栈顶的一个结点，再进行新的循环。同时，找到目的结点时停止搜索。
2. 完备性

   > 可以发现深度搜索会一直搜索到最深层的结点才会返回一层，所以在有限状态空间也即分支因子$b$和搜索最深层数$m$有限时，如果设计时绕过了回路则DFS算法是完备的。否则，DFS是不完备的。
3. 时间复杂度

   > 类似BFS，DFS会搜索所有可能的状态，所以DFS时间复杂度是$O(b^m)$
4. 空间复杂度

   > DFS的空间使用来自栈的空间，而栈的最大大小是搜索的最大深度过程中存入的结点数量，所以空间复杂度是$O(bm)$
5. 最优性

   > DFS不像BFS和UCS那样维护了结点按代价排序搜索，所以不能保证最优性

## 深度受限算法(Depth Limited Search,DLS)
1. DLS算法描述

   > DLS算法为深度优先搜索设置了一个最大搜索深度，我们假设是$l$，那么DLS仍然采用深度优先搜索的策略，但是在达到深度$l$后立即返回，不再继续深入搜索。
2. 完备性

   > DLS设置了深度限制，并不会搜索所有的状态。特别是如最浅解的深度超过$l$，DLS算法不可能找到解，所以这个算法此时是不完备的。
3. 时间复杂度

   > DLS的时间复杂度是$O(b^l)$
4. 空间复杂度

   > DLS的空间复杂度是栈的最大大小，为$O(bl)$
5. 最优性

   > DLS显然不是最优的，即使我们选择的$l$大于最浅解的深度。

## 迭代加深算法(Iterative Deepening Search,IDS)
1. IDS算法描述 

   > IDS算法基于深度优先搜索，只不过它会逐步加大深度限制，从0开始，到1、2...等，并确认最好的深度界限。假设最浅的解位于深度$d$时，在$d$层限制的深度优先搜索找到解以后搜索停止。
2. 完备性

   > 当分支因子$b$有限时，IDS是完备的。
3. 时间复杂度

   > 搜索时$d-1,\dots,0$层的结点的子结点分别搜索了$1,2,\dots,d$次，所以一共搜索$d\cdot b+(d-1)b^2+\dots+1\cdot b^d$次，时间复杂度是$O(b^d)$。
4. 空间复杂度

   > 空间复杂度是最大深度限制时DFS所使用的栈的最大大小，是$O(bd)$
5. 最优性

   > 当代价函数是结点深度的非减函数是IDS是最优的。